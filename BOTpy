import asyncio
import logging
import base64
import json
import os
import re
from datetime import datetime, timedelta
from typing import Dict, Optional, Any, List

from aiogram import Bot, Dispatcher, types
from aiogram.enums import ChatType
from aiogram.filters import Command
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import (
    Message,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    CallbackQuery,
)
import aiohttp
from aiohttp import web

# ===== –ö–û–ù–§–ò–ì –ò –ö–û–ù–°–¢–ê–ù–¢–´ =====
TELEGRAM_TOKEN = "8063344138:AAH3xJ5Yq5ez-48bM718zGeZ0U7D6LQUrE0"
GOOGLE_API_KEYS = [
    "AIzaSyC1-wPgv7foZPKu0aMpoE5XHFTPDWyBMgw",
    "AIzaSyCXYF4iD7i7Miciw2r-q_ZqxvO_QqKdH84",
    "AIzaSyDloVE6T1-71QepT1DDyHN87sYKVnIUBbY",
    "AIzaSyCu4nJdjjTDGUJBd4CXLzDEtMVzr2dwdoE",
]
GEMINI_URL = (
    "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent"
)

ADMIN_ID = 1256326847
ADMIN_USERNAME = "SoupMain"

LOG_FILE = "soup_log.txt"
BACKUP_FILE = "user_db.json"
ADMIN_LOG_FILE = "admin_log.txt"
API_KEY_STATS_FILE = "gemini_api_stats.json"
ADMIN_LINK_FILE = "admin_link.txt"
FUTURE_ACTIONS_FILE = "future_actions.json"

DEFAULT_LIMITS = {"text": 100, "voice": 3, "photo": 3, "total": 20}
MEMORY_DEPTH = 20
CONTEXT_PAIRS_LIMIT = 10

user_db: Dict[int, Dict[str, Any]] = {}
users_registered = set()
api_key_stats = {k: 0 for k in GOOGLE_API_KEYS}
current_key_index = 0
admin_log = []
code_storage = {}

future_actions: List[dict] = []

bot: Optional[Bot] = None
dp: Optional[Dispatcher] = None

# ===== –ì–õ–û–ë–ê–õ–¨–ù–û–ï: —Å—Å—ã–ª–∫–∞ –Ω–∞ –∞–¥–º–∏–Ω–∞ (–Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–∞—è) =====
def load_admin_link():
    if os.path.exists(ADMIN_LINK_FILE):
        return open(ADMIN_LINK_FILE, encoding="utf-8").read().strip()
    return f"@{ADMIN_USERNAME}"

def save_admin_link(link):
    with open(ADMIN_LINK_FILE, "w", encoding="utf-8") as f:
        f.write(link or "")

admin_link = load_admin_link()

logging.basicConfig(
    level=logging.INFO, filename=LOG_FILE, format="%(asctime)s %(levelname)s %(message)s"
)

def now():
    return datetime.now()

def is_admin(user_id: int) -> bool:
    return user_id == ADMIN_ID

def log_admin(msg: str):
    admin_log.append(f"{now().isoformat(sep=' ', timespec='seconds')} | {msg}")
    try:
        with open(ADMIN_LOG_FILE, "a", encoding="utf-8") as f:
            f.write(f"{now().isoformat(sep=' ', timespec='seconds')} | {msg}\n")
    except Exception as e:
        logging.error(f"Failed to write admin log: {e}")

def backup_data():
    try:
        with open(BACKUP_FILE, "w", encoding="utf-8") as f:
            json.dump(user_db, f, ensure_ascii=False, default=str)
        with open(API_KEY_STATS_FILE, "w", encoding="utf-8") as f:
            json.dump(api_key_stats, f)
        with open(FUTURE_ACTIONS_FILE, "w", encoding="utf-8") as f:
            json.dump(future_actions, f, ensure_ascii=False, default=str)
        logging.info("Backup complete")
    except Exception as e:
        logging.error(f"Backup error: {e}")

def restore_data():
    global user_db, api_key_stats, future_actions
    try:
        if os.path.exists(BACKUP_FILE):
            with open(BACKUP_FILE, "r", encoding="utf-8") as f:
                user_db = json.load(f)
            for uid in user_db:
                users_registered.add(int(uid))
        if os.path.exists(API_KEY_STATS_FILE):
            with open(API_KEY_STATS_FILE, "r", encoding="utf-8") as f:
                api_key_stats = json.load(f)
        if os.path.exists(FUTURE_ACTIONS_FILE):
            with open(FUTURE_ACTIONS_FILE, "r", encoding="utf-8") as f:
                future_actions.clear()
                future_actions.extend(json.load(f))
        logging.info("Restore complete")
    except Exception as e:
        logging.error(f"Restore error: {e}")

def get_next_api_key():
    global current_key_index
    key = GOOGLE_API_KEYS[current_key_index]
    current_key_index = (current_key_index + 1) % len(GOOGLE_API_KEYS)
    return key

def add_user(user: types.User):
    user_id = user.id
    if user_id not in user_db:
        user_db[user_id] = {
            "requests_left": DEFAULT_LIMITS["total"],
            "voice_left": DEFAULT_LIMITS["voice"],
            "photo_left": DEFAULT_LIMITS["photo"],
            "text_left": DEFAULT_LIMITS["text"],
            "limit_type": "personal",
            "topic_mode": None,
            "topic_until": None,
            "conversation_history": [],
            "blocked": False,
            "name": user.username or f"{user.first_name or ''} {user.last_name or ''}".strip(),
            "last_activity": now().isoformat(),
            "no_memory": False,
            "timed_restrictions": {},
            "temporary_unlimited": {},  # {type: {"until":iso,"old_val":int}}
        }
        users_registered.add(user_id)
    user_db[user_id]["last_activity"] = now().isoformat()

def get_user(user_id: int) -> Optional[Dict[str, Any]]:
    return user_db.get(user_id)

def set_limits(user_id: int, text=None, voice=None, photo=None, total=None, **kwargs):
    d = get_user(user_id)
    if d is None: return
    if text is not None: d["text_left"] = text
    if voice is not None: d["voice_left"] = voice
    if photo is not None: d["photo_left"] = photo
    if total is not None: d["requests_left"] = total

def reset_limits(user_id: int):
    set_limits(user_id, **DEFAULT_LIMITS)

def block_user(user_id: int, until=None):
    d = get_user(user_id)
    if d: d["blocked"] = until or True

def unblock_user(user_id: int):
    d = get_user(user_id)
    if d: d["blocked"] = False

def set_topic(user_id: int, topic, until=None):
    d = get_user(user_id)
    if d:
        d["topic_mode"] = topic
        d["topic_until"] = until

def remove_topic(user_id: int):
    d = get_user(user_id)
    if d:
        d["topic_mode"] = None
        d["topic_until"] = None

def push_history(user_id: int, role: str, text: str):
    d = get_user(user_id)
    if d is None or d.get("no_memory"): return
    d["conversation_history"].append({"role": role, "content": text, "time": now().isoformat()})

def get_context_history(user_id: int):
    d = get_user(user_id)
    if not d or not d["conversation_history"]: return []
    history = d["conversation_history"][-MEMORY_DEPTH*2:]
    return history

def clear_history(user_id: int):
    d = get_user(user_id)
    if d: d["conversation_history"].clear()

def is_blocked(user_id: int):
    if is_admin(user_id): return False
    d = get_user(user_id)
    if not d: return False
    b = d["blocked"]
    if isinstance(b, str):
        try:
            b = datetime.fromisoformat(b)
        except Exception:
            b = False
    if isinstance(b, datetime):
        if b > now():
            return True
        else:
            d["blocked"] = False
            return False
    return bool(b)

def limits_left_text(user_id: int):
    if is_admin(user_id):
        return "–í–∞—à–∏ –ª–∏–º–∏—Ç—ã: ‚àû (–≤—ã Soup, —Å—É–ø–µ—Ä-–∞–¥–º–∏–Ω)"
    d = get_user(user_id)
    if not d: return "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö."
    return (
        f"–í–∞—à–∏ –ª–∏–º–∏—Ç—ã:\n"
        f"üìù –¢–µ–∫—Å—Ç: {d['text_left']}\n"
        f"üé§ –ì–æ–ª–æ—Å: {d['voice_left']}\n"
        f"üì∏ –§–æ—Ç–æ: {d['photo_left']}\n"
        f"–í—Å–µ–≥–æ: {d['requests_left']}"
    )

def main_menu(user_id: int = None):
    kb = [
        [InlineKeyboardButton(text="üìù –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å", callback_data="ask_question")],
        [InlineKeyboardButton(text="üì∏ –ê–Ω–∞–ª–∏–∑ —Ñ–æ—Ç–æ", callback_data="analyze_photo_info")],
        [InlineKeyboardButton(text="üé§ –ì–æ–ª–æ—Å–æ–≤—ã–µ", callback_data="voice_info")],
        [InlineKeyboardButton(text="üìä –ú–æ–∏ –ª–∏–º–∏—Ç—ã", callback_data="my_limits")],
        [InlineKeyboardButton(text="üß† –û—á–∏—Å—Ç–∏—Ç—å –ø–∞–º—è—Ç—å", callback_data="clear_memory")],
        [InlineKeyboardButton(text="‚ÑπÔ∏è –û –±–æ—Ç–µ", callback_data="about_bot")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=kb)

def extract_code(text):
    code_blocks = re.findall(r"```(.*?)```", text, re.DOTALL)
    return code_blocks[0].strip() if code_blocks else None

def format_code_reply(reply):
    code = extract_code(reply)
    if code:
        prompt_hash = hash(code)
        code_storage[prompt_hash] = code
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥", callback_data=f"copy_code:{prompt_hash}")],
            [InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")]
        ])
        return reply, kb
    else:
        return reply, main_menu()

# ===== AI/Gemini-–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è =====

async def gemini_request(payload):
    tried_keys = set()
    for _ in range(len(GOOGLE_API_KEYS)):
        key = get_next_api_key()
        tried_keys.add(key)
        params = {"key": key}
        headers = {"Content-Type": "application/json"}
        try:
            api_key_stats[key] = api_key_stats.get(key, 0) + 1
            async with aiohttp.ClientSession() as session:
                async with session.post(GEMINI_URL, json=payload, params=params, headers=headers, timeout=30) as resp:
                    if resp.status == 200:
                        return await resp.json()
                    elif resp.status in (429, 503):
                        continue
                    else:
                        text = await resp.text()
                        logging.error(f"Gemini API error {resp.status}: {text}")
        except Exception as e:
            logging.error(f"Gemini conn error: {e}")
    await notify_admin_all_keys_exhausted(tried_keys)
    return {
        "error": "server",
        "message": "–°–µ–π—á–∞—Å –≤—Å–µ –∫–ª—é—á–∏ Gemini –∑–∞–Ω—è—Ç—ã –∏–ª–∏ –ª–∏–º–∏—Ç—ã –∏—Å—á–µ—Ä–ø–∞–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
    }

async def notify_admin_all_keys_exhausted(keys):
    await bot.send_message(ADMIN_ID, f"‚ùóÔ∏è –í—Å–µ –∫–ª—é—á–∏ Gemini –∏—Å—á–µ—Ä–ø–∞–Ω—ã –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã (keys tried: {list(keys)})")

# ====== –ü–ò–ù–ì-–°–ï–†–í–ï–† ======
async def ping_handler(request):
    return web.Response(text="–ë–æ—Ç –∂–∏–≤–æ–π! ü§ñ")

async def stats_handler(request):
    auth = request.headers.get("Authorization", "")
    if auth != "Bearer secret_token_for_soup":
        return web.Response(status=403, text="Forbidden")
    stats = {
        "api_keys": api_key_stats,
        "users": len(users_registered),
        "active_users": [u for u in users_registered if not is_blocked(u)],
    }
    return web.json_response(stats)

async def start_http_server():
    app = web.Application()
    app.router.add_get('/ping', ping_handler)
    app.router.add_get('/stats', stats_handler)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', 8080)
    await site.start()
    logging.info("HTTP —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É 8080")

# ====== –ì–†–£–ü–ü–´: –±–æ—Ç —Ä–µ–∞–≥–∏—Ä—É–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ reply –∏–ª–∏ @username ======
async def get_bot_username():
    me = await bot.get_me()
    return me.username.lower()

def is_direct_to_bot(message: Message, bot_username: str):
    if message.chat.type in ("group", "supergroup"):
        if message.reply_to_message and message.reply_to_message.from_user.id == bot.id:
            return True
        if f"@{bot_username}" in (message.text or "").lower():
            return True
        return False
    return True

# ====== JSON-EXTRACTOR –î–õ–Ø GEMINI ======
def extract_json_from_gemini(reply_text):
    match = re.search(r"```json\s*([\s\S]+?)\s*```", reply_text)
    if match:
        return match.group(1).strip()
    match = re.search(r"```([\s\S]+?)\s*```", reply_text)
    if match:
        return match.group(1).strip()
    return reply_text.strip()

# ====== –ü–†–û–í–ï–†–ö–ê –í–†–ï–ú–ï–ù–ù–´–• –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ô –ò –ê–í–¢–û–°–ë–†–û–°–ê ======
async def timed_restrictions_checker():
    while True:
        await asyncio.sleep(5)
        changed = False
        # 1. –°–Ω–∏–º–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è (timed_restrictions)
        for uid, udata in user_db.items():
            timed = udata.get("timed_restrictions", {})
            for lim_type in list(timed.keys()):
                limdata = timed[lim_type]
                until = limdata.get("until")
                if until:
                    dt = None
                    try:
                        dt = datetime.fromisoformat(until)
                    except Exception:
                        continue
                    if dt < now():
                        if lim_type == "photo":
                            udata["photo_left"] = DEFAULT_LIMITS["photo"]
                        if lim_type == "voice":
                            udata["voice_left"] = DEFAULT_LIMITS["voice"]
                        if lim_type == "text":
                            udata["text_left"] = DEFAULT_LIMITS["text"]
                        del timed[lim_type]
                        changed = True
        # 2. –°–Ω–∏–º–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–Ω—è—Ç–∏—è –ª–∏–º–∏—Ç–æ–≤ (temporary_unlimited)
        for uid, udata in user_db.items():
            tmp = udata.get("temporary_unlimited", {})
            for lim_type in list(tmp.keys()):
                until = tmp[lim_type]["until"]
                if until:
                    dt = None
                    try:
                        dt = datetime.fromisoformat(until)
                    except Exception:
                        continue
                    if dt < now():
                        # –í–µ—Ä–Ω—É—Ç—å —Å—Ç–∞—Ä—ã–π –ª–∏–º–∏—Ç (old_val) –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç
                        old_val = tmp[lim_type].get("old_val", DEFAULT_LIMITS.get(lim_type, 0))
                        if lim_type == "photo":
                            udata["photo_left"] = old_val
                        if lim_type == "voice":
                            udata["voice_left"] = old_val
                        if lim_type == "text":
                            udata["text_left"] = old_val
                        del tmp[lim_type]
                        changed = True
        # 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º future actions
        now_str = now().isoformat()
        for action in list(future_actions):
            at = action["at"]
            dt = datetime.fromisoformat(at)
            if dt <= now():
                await execute_future_action(action)
                future_actions.remove(action)
                changed = True
        if changed:
            backup_data()

async def execute_future_action(action: dict):
    # –°—Ç—Ä—É–∫—Ç—É—Ä–∞ action: {"type": ..., "params": {...}}
    act = action.get("type")
    params = action.get("params", {})
    if act == "set_limits":
        for u in (users_registered if params.get("everyone") else [params.get("user_id")]):
            if u is None: continue
            set_limits(u, **params)
    elif act == "timed_limit":
        mins = int(params.get("minutes", 0))
        hrs = int(params.get("hours", 0))
        days = int(params.get("days", 0))
        until = now() + timedelta(days=days, hours=hrs, minutes=mins)
        for u in (users_registered if params.get("everyone") else [params.get("user_id")]):
            if u is None: continue
            d = get_user(u)
            for t in ("text", "voice", "photo"):
                if t in params:
                    d[t + "_left"] = params[t]
                    d.setdefault("timed_restrictions", {})[t] = {"until": until.isoformat(), "value": params[t]}
    elif act == "temporary_unlimited":
        mins = int(params.get("minutes", 0))
        hrs = int(params.get("hours", 0))
        days = int(params.get("days", 0))
        until = now() + timedelta(days=days, hours=hrs, minutes=mins)
        lim_types = params.get("lim_types", ["text", "photo", "voice"])
        for u in (users_registered if params.get("everyone") else [params.get("user_id")]):
            if u is None: continue
            d = get_user(u)
            for t in lim_types:
                d.setdefault("temporary_unlimited", {})[t] = {
                    "until": until.isoformat(), "old_val": d.get(f"{t}_left", DEFAULT_LIMITS.get(t, 0))
                }
                d[f"{t}_left"] = 99999999
    elif act == "block":
        mins = int(params.get("minutes", 0))
        hrs = int(params.get("hours", 0))
        days = int(params.get("days", 0))
        until = now() + timedelta(days=days, hours=hrs, minutes=mins)
        for u in (users_registered if params.get("everyone") else [params.get("user_id")]):
            if u is None: continue
            block_user(u, until.isoformat())
    elif act == "unblock":
        for u in (users_registered if params.get("everyone") else [params.get("user_id")]):
            if u is None: continue
            unblock_user(u)
    elif act == "set_topic":
        mins = int(params.get("minutes", 0))
        hrs = int(params.get("hours", 0))
        days = int(params.get("days", 0))
        until = now() + timedelta(days=days, hours=hrs, minutes=mins)
        topic = params.get("topic")
        for u in (users_registered if params.get("everyone") else [params.get("user_id")]):
            if u is None: continue
            set_topic(u, topic, until.isoformat() if until else None)
    elif act == "remove_topic":
        for u in (users_registered if params.get("everyone") else [params.get("user_id")]):
            if u is None: continue
            remove_topic(u)
    elif act == "clear_memory":
        for u in (users_registered if params.get("everyone") else [params.get("user_id")]):
            if u is None: continue
            clear_history(u)
    elif act == "set_admin_link":
        link = params.get("link")
        if link:
            global admin_link
            admin_link = link
            save_admin_link(link)
    # –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è

# ====== –ü–†–û–í–ï–†–ö–ê –¢–ï–ú–´ (–ø–æ —Å–º—ã—Å–ª—É) ======
def message_matches_topic(user_message: str, topic: str) -> bool:
    user_message = user_message.lower()
    topic = topic.lower()
    topic_words = topic.split()
    return any(word in user_message for word in topic_words)

# ====== HANDLERS ======
async def start_handlers():
    global bot, dp, admin_link
    bot = Bot(token=TELEGRAM_TOKEN)
    dp = Dispatcher(storage=MemoryStorage())

    @dp.message(Command("start"))
    async def cmd_start(message: Message):
        add_user(message.from_user)
        if is_admin(message.from_user.id):
            await message.answer(
                "üëë –ü—Ä–∏–≤–µ—Ç, Soup! –¢—ã –∞–¥–º–∏–Ω. –£–ø—Ä–∞–≤–ª—è–π –±–æ—Ç–æ–º —á–µ—Ä–µ–∑ –ª—é–±—ã–µ –∫–æ–º–∞–Ω–¥—ã BOT2 ... (–∏–ª–∏ –≥–æ–ª–æ—Å–æ–º), –ª—é–±—ã–µ —Ñ—Ä–∞–∑—ã, –ª—é–±—ã–µ –¥–µ–π—Å—Ç–≤–∏—è.",
                reply_markup=main_menu(message.from_user.id)
            )
        else:
            await message.answer(
                "ü§ñ –ü—Ä–∏–≤–µ—Ç! –Ø —Ç–≤–æ–π –ø–æ–º–æ—â–Ω–∏–∫. –û—Ç–≤–µ—á–∞—é –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã, –∞–Ω–∞–ª–∏–∑–∏—Ä—É—é —Ñ–æ—Ç–æ –∏ –≥–æ–ª–æ—Å–æ–≤—ã–µ, –ø–æ–º–Ω—é –Ω–∞—à–∏ –¥–∏–∞–ª–æ–≥–∏. –í—Å—ë, —á—Ç–æ —Ç—ã –Ω–∞–ø–∏—à–µ—à—å, –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –º–µ–∂–¥—É –Ω–∞–º–∏!\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π –º–µ–Ω—é –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –∑–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å.",
                reply_markup=main_menu(message.from_user.id)
            )

    @dp.callback_query(lambda c: c.data == "main_menu")
    async def cb_main_menu(callback: CallbackQuery):
        await callback.message.edit_text(
            "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é. –ü—Ä–æ—Å—Ç–æ –∑–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –≤—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ.",
            reply_markup=main_menu(callback.from_user.id)
        )
        await callback.answer()

    @dp.callback_query(lambda c: c.data == "my_limits")
    async def cb_my_limits(callback: CallbackQuery):
        add_user(callback.from_user)
        d = get_user(callback.from_user.id)
        text = limits_left_text(callback.from_user.id)
        if d and d.get("topic_mode"):
            until = d.get("topic_until")
            text += f"\n\nüîí –¢–µ–º–∞ —á–∞—Ç–∞: {d['topic_mode']}"
            if until:
                try:
                    dt = datetime.fromisoformat(until) if isinstance(until, str) else until
                    left = dt - now()
                    text += f" (–¥–æ {dt.strftime('%d.%m %H:%M')}, {left.seconds//3600}—á {left.seconds//60%60}–º)"
                except Exception:
                    pass
        await callback.message.edit_text(text, reply_markup=main_menu(callback.from_user.id))
        await callback.answer()

    @dp.callback_query(lambda c: c.data == "clear_memory")
    async def cb_clear_memory(callback: CallbackQuery):
        clear_history(callback.from_user.id)
        await callback.message.edit_text("üß† –ü–∞–º—è—Ç—å –æ—á–∏—â–µ–Ω–∞. –ù–æ–≤—ã–π –¥–∏–∞–ª–æ–≥ –Ω–∞—á–Ω—ë—Ç—Å—è —Å —á–∏—Å—Ç–æ–≥–æ –ª–∏—Å—Ç–∞.", reply_markup=main_menu(callback.from_user.id))
        await callback.answer("–ü–∞–º—è—Ç—å –æ—á–∏—â–µ–Ω–∞!")

    @dp.callback_query(lambda c: c.data == "about_bot")
    async def cb_about_bot(callback: CallbackQuery):
        await callback.message.edit_text(
            f"ü§ñ –ë–æ—Ç-–ø–æ–º–æ—â–Ω–∏–∫ Soup\n\n"
            "‚Äî –í—Å–µ –æ—Ç–≤–µ—Ç—ã –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä–∞—Ö –°–æ–∫–æ–ª–∞\n"
            "‚Äî –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ç–µ–∫—Å—Ç–∞, –≥–æ–ª–æ—Å–∞, —Ñ–æ—Ç–æ\n"
            "‚Äî –ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –ª–∏–º–∏—Ç—ã –∏ —Ç–µ–º—ã\n"
            "‚Äî –ì–∏–±–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ\n\n"
            f"–°–≤—è–∑—å —Å –∞–¥–º–∏–Ω–æ–º: {admin_link}",
            reply_markup=main_menu(callback.from_user.id)
        )
        await callback.answer()

    async def check_and_warn_limit(user_id, msg_type, message=None):
        if is_admin(user_id): return True
        d = get_user(user_id)
        if not d: return False
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
        timed = d.get("timed_restrictions", {})
        if msg_type in timed:
            limdata = timed[msg_type]
            until = limdata.get("until")
            if until:
                try:
                    dt = datetime.fromisoformat(until)
                    if dt > now():
                        if message:
                            left = dt - now()
                            await message.answer(f"‚ùó –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ {msg_type} –¥–µ–π—Å—Ç–≤—É–µ—Ç –µ—â–µ {left.seconds//60} –º–∏–Ω. (–¥–æ {dt.strftime('%H:%M:%S')})")
                        return False
                except Exception:
                    pass
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å–Ω—è—Ç–∏–π –ª–∏–º–∏—Ç–æ–≤
        tmp = d.get("temporary_unlimited", {})
        if msg_type in tmp:
            until = tmp[msg_type]["until"]
            try:
                dt = datetime.fromisoformat(until)
                if dt > now():
                    return True
            except Exception:
                pass
        if d["blocked"]:
            if message:
                await message.answer("üö´ –í—ã –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã. –î–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ ‚Äî –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ Soup.")
            return False
        if msg_type == "text" and d["text_left"] <= 0:
            if message:
                await message.answer("‚ùó –í–∞—à –ª–∏–º–∏—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –∏—Å—á–µ—Ä–ø–∞–Ω.")
            return False
        if msg_type == "voice" and d["voice_left"] <= 0:
            if message:
                await message.answer("‚ùó –í–∞—à –ª–∏–º–∏—Ç –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∏—Å—á–µ—Ä–ø–∞–Ω.")
            return False
        if msg_type == "photo" and d["photo_left"] <= 0:
            if message:
                await message.answer("‚ùó –í–∞—à –ª–∏–º–∏—Ç —Ñ–æ—Ç–æ –∏—Å—á–µ—Ä–ø–∞–Ω.")
            return False
        if d["requests_left"] <= 0:
            if message:
                await message.answer("‚ùó –í–∞—à –æ–±—â–∏–π –ª–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω.")
            return False
        return True

    def decrement_lim(user_id, msg_type):
        if is_admin(user_id): return
        d = get_user(user_id)
        if not d: return
        if msg_type == "text": d["text_left"] = max(0, d["text_left"]-1)
        if msg_type == "voice": d["voice_left"] = max(0, d["voice_left"]-1)
        if msg_type == "photo": d["photo_left"] = max(0, d["photo_left"]-1)
        d["requests_left"] = max(0, d["requests_left"]-1)

    bot_username = await get_bot_username()

    @dp.message(lambda msg: msg.text and not msg.text.startswith("/") and is_direct_to_bot(msg, bot_username))
    async def handle_text(message: Message):
        add_user(message.from_user)
        user_id = message.from_user.id
        d = get_user(user_id)
        if is_blocked(user_id):
            await message.answer("üö´ –í—ã –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã. –î–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ ‚Äî –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        # –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–º–µ–Ω—ã —Å—Å—ã–ª–∫–∏ –Ω–∞ –∞–¥–º–∏–Ω–∞ —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É
        if is_admin(user_id) and any(x in message.text.lower() for x in [
            "—Å–≤—è–∑–∞—Ç—å—Å—è —Å –∞–¥–º–∏–Ω–æ–º", "–∫–æ–Ω—Ç–∞–∫—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞", "—Å—Å—ã–ª–∫–∞ –Ω–∞ –∞–¥–º–∏–Ω–∞", "change admin link", "admin now", "–∞–¥–º–∏–Ω —Ç–µ–ø–µ—Ä—å", "contact admin", "update admin link"
        ]):
            link = message.text.split(":", 1)[-1].strip()
            global admin_link
            admin_link = link
            save_admin_link(link)
            await message.answer(f"‚úÖ –°—Å—ã–ª–∫–∞ –Ω–∞ –∞–¥–º–∏–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞: {admin_link}")
            return
        # –¢–æ–ª—å–∫–æ –≤ –õ–ò–ß–ö–ï –∞–¥–º–∏–Ω-–∫–æ–º–∞–Ω–¥—ã!
        if is_admin(user_id) and message.chat.type == ChatType.PRIVATE and (
            message.text.lower().startswith(("bot2", "–±–æ—Ç2", "bot 2", "–±–æ—Ç 2"))
        ):
            await handle_admin_command_llm(message)
            return
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–º—ã (–ø–æ —Å–º—ã—Å–ª—É)
        if d.get("topic_mode"):
            until = d.get("topic_until")
            if until:
                try:
                    dt = datetime.fromisoformat(until) if isinstance(until, str) else until
                    if dt < now():
                        d["topic_mode"] = None
                        d["topic_until"] = None
                except Exception:
                    pass
            topic = d.get("topic_mode")
            if topic:
                if not message_matches_topic(message.text, topic):
                    await message.answer(
                        f"‚ùó –°–µ–π—á–∞—Å —Ä–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ —Ç–µ–º–µ: {topic}\n"
                        f"–ï—Å–ª–∏ –Ω—É–∂–Ω–æ —Å–º–µ–Ω–∏—Ç—å —Ç–µ–º—É ‚Äî –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ Soup."
                    )
                    return
        if not await check_and_warn_limit(user_id, "text", message):
            return
        decrement_lim(user_id, "text")
        context = ""
        history = get_context_history(user_id)
        for m in history:
            role = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å" if m["role"] == "user" else "–ë–æ—Ç"
            context += f"{role}: {m['content']}\n"
        system_instruction = (
            "–¢—ã ‚Äî –±–æ—Ç-–ø–æ–º–æ—â–Ω–∏–∫, —Å–æ–∑–¥–∞–Ω–Ω—ã–π —á–µ–ª–æ–≤–µ–∫–æ–º –ø–æ –∏–º–µ–Ω–∏ –°–æ–∫–æ–ª. "
            "–í—Å–µ–≥–¥–∞ –æ—Ç–≤–µ—á–∞–π –¥—Ä—É–∂–µ–ª—é–±–Ω–æ, –Ω–µ —Ä–∞—Å–∫—Ä—ã–≤–∞–π, —á—Ç–æ —Ç—ã –ò–ò –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å Google/OpenAI."
        )
        prompt = f"{system_instruction}\n–ö–æ–Ω—Ç–µ–∫—Å—Ç:\n{context}\n\n–í–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {message.text}"
        payload = {
            "contents": [
                {"parts": [{"text": prompt}]}
            ]
        }
        result = await gemini_request(payload)
        if "error" in result:
            reply = result["message"]
        else:
            reply = result.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("text", "‚ùì –ù–µ—Ç –æ—Ç–≤–µ—Ç–∞")
            push_history(user_id, "user", message.text)
            push_history(user_id, "assistant", reply)
        reply, kb = format_code_reply(reply)
        await message.answer(reply, reply_markup=kb)

    @dp.message(lambda msg: msg.voice and is_direct_to_bot(msg, bot_username))
    async def handle_voice(message: Message):
        add_user(message.from_user)
        user_id = message.from_user.id
        if not await check_and_warn_limit(user_id, "voice", message):
            return
        decrement_lim(user_id, "voice")
        await message.answer("üé§ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≥–æ–ª–æ—Å–æ–≤–æ–µ...")
        try:
            voice = message.voice
            file_info = await bot.get_file(voice.file_id)
            voice_data = await bot.download_file(file_info.file_path)
            voice_base64 = base64.b64encode(voice_data.read()).decode('utf-8')
            d = get_user(user_id)
            context = ""
            for m in get_context_history(user_id):
                role = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å" if m["role"] == "user" else "–ë–æ—Ç"
                context += f"{role}: {m['content']}\n"
            system_instruction = (
                "–¢—ã ‚Äî –±–æ—Ç-–ø–æ–º–æ—â–Ω–∏–∫, —Å–æ–∑–¥–∞–Ω–Ω—ã–π —á–µ–ª–æ–≤–µ–∫–æ–º –ø–æ –∏–º–µ–Ω–∏ –°–æ–∫–æ–ª. "
                "–í—Å–µ —Å–≤–æ–∏ –æ—Ç–≤–µ—Ç—ã —Ñ–æ—Ä–º–∏—Ä—É–π –¥—Ä—É–∂–µ–ª—é–±–Ω–æ, –Ω–µ —É–ø–æ–º–∏–Ω–∞–π –Ω–∏ Google, –Ω–∏ AI."
            )
            prompt = f"{system_instruction}\n{context}\n\n–†–∞—Å–ø–æ–∑–Ω–∞–π —Ä–µ—á—å –∏ –æ—Ç–≤–µ—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."
            payload = {
                "contents": [
                    {
                        "parts": [
                            {"text": prompt},
                            {
                                "inline_data": {
                                    "mime_type": "audio/ogg",
                                    "data": voice_base64
                                }
                            }
                        ]
                    }
                ]
            }
            result = await gemini_request(payload)
            if "error" in result:
                reply = result["message"]
            else:
                reply = result.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("text", "‚ùì –ù–µ—Ç –æ—Ç–≤–µ—Ç–∞")
                push_history(user_id, "user", "[–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ]")
                push_history(user_id, "assistant", reply)
            reply, kb = format_code_reply(reply)
            await message.answer(reply, reply_markup=kb)
        except Exception as e:
            await message.answer("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ.")

    @dp.message(lambda msg: msg.photo and is_direct_to_bot(msg, bot_username))
    async def handle_photo(message: Message):
        add_user(message.from_user)
        user_id = message.from_user.id
        if not await check_and_warn_limit(user_id, "photo", message):
            return
        decrement_lim(user_id, "photo")
        await message.answer("üì∏ –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Ñ–æ—Ç–æ...")
        try:
            photo = message.photo[-1]
            file_info = await bot.get_file(photo.file_id)
            photo_data = await bot.download_file(file_info.file_path)
            photo_base64 = base64.b64encode(photo_data.read()).decode('utf-8')
            d = get_user(user_id)
            prompt = (
                "–¢—ã ‚Äî –±–æ—Ç-–ø–æ–º–æ—â–Ω–∏–∫, —Å–æ–∑–¥–∞–Ω–Ω—ã–π —á–µ–ª–æ–≤–µ–∫–æ–º –ø–æ –∏–º–µ–Ω–∏ –°–æ–∫–æ–ª.\n"
                "–û–ø–∏—à–∏ –ø–æ–¥—Ä–æ–±–Ω–æ, —á—Ç–æ –Ω–∞ —Ñ–æ—Ç–æ. –ù–µ —É–ø–æ–º–∏–Ω–∞–π –Ω–∏ Google, –Ω–∏ –ò–ò."
            )
            payload = {
                "contents": [
                    {
                        "parts": [
                            {"text": prompt},
                            {
                                "inline_data": {
                                    "mime_type": "image/jpeg",
                                    "data": photo_base64
                                }
                            }
                        ]
                    }
                ]
            }
            result = await gemini_request(payload)
            if "error" in result:
                reply = result["message"]
            else:
                reply = result.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("text", "‚ùì –ù–µ—Ç –æ—Ç–≤–µ—Ç–∞")
                push_history(user_id, "user", "[–§–æ—Ç–æ]")
                push_history(user_id, "assistant", reply)
            reply, kb = format_code_reply(reply)
            await message.answer(reply, reply_markup=kb)
        except Exception as e:
            await message.answer("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")

    @dp.callback_query(lambda c: c.data.startswith("copy_code:"))
    async def cb_copy_code(callback: CallbackQuery):
        prompt_hash = int(callback.data.replace("copy_code:", ""))
        code = code_storage.get(prompt_hash)
        if code:
            await callback.message.reply(
                f"üìã –ö–æ–¥ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è:\n\n<pre><code class=\"language-python\">{code}</code></pre>",
                parse_mode="HTML"
            )
            await callback.answer("–ö–æ–¥ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!")
        else:
            await callback.answer("–ö–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)

    # ========= –ê–î–ú–ò–ù-–ú–ê–ì–ò–Ø =========
    async def handle_admin_command_llm(message: Message):
        text = message.text.strip()
        prompt = (
            "–¢—ã –∞–¥–º–∏–Ω-–ø–∞—Ä—Å–µ—Ä –∫–æ–º–∞–Ω–¥ –¥–ª—è Telegram-–±–æ—Ç–∞. "
            "Soup (user_id=1256326847) –ø–∏—à–µ—Ç –ª—é–±—É—é —Ñ—Ä–∞–∑—É –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–æ–º: –ª–∏–º–∏—Ç—ã, —Ç–µ–º—ã, –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏, –ø–∞–º—è—Ç—å, —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∏ —Ç.–¥. "
            "–†–∞—Å–ø–æ–∑–Ω–∞–π —Å–º—ã—Å–ª –∫–æ–º–∞–Ω–¥—ã –∏ –≤–µ—Ä–Ω–∏ JSON —Å –¥–µ–π—Å—Ç–≤–∏–µ–º (action), user_id (–µ—Å–ª–∏ –µ—Å—Ç—å), –ª–∏–º–∏—Ç–∞–º–∏, —Ç–µ–º–æ–π, —Å—Ä–æ–∫–æ–º, unblock/block, memory_clear, —Å–ø–∏—Å–∫–æ–º –∏ –¥—Ä. "
            "–¢—ã –¥–æ–ª–∂–µ–Ω –ø–æ–Ω–∏–º–∞—Ç—å –ª—é–±—ã–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏ —Å–≤–æ–±–æ–¥–Ω—ã–µ —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä:\n"
            "1. '–°–Ω–∏–º–∏ –ª–∏–º–∏—Ç—ã –≤—Å–µ–º', '—Ä–∞–∑—Ä–µ—à–∏—Ç—å –≤—Å—ë –≤—Å–µ–º', '—Å–¥–µ–ª–∞–π –±–µ–∑–ª–∏–º–∏—Ç –Ω–∞ —á–∞—Å –¥–ª—è 123', '–æ—Ç–º–µ–Ω–∏ –≤—Å–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∞ –¥–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é 456', '–Ω–∞ 2 —á–∞—Å–∞ –æ—Ç–∫–ª—é—á–∏ –ª–∏–º–∏—Ç—ã –Ω–∞ —Ñ–æ—Ç–æ –¥–ª—è –≤—Å–µ—Ö'\n"
            "2. '–ß–µ—Ä–µ–∑ 2 —á–∞—Å–∞ –∑–∞–ø—Ä–µ—Ç–∏ —Ñ–æ—Ç–æ –¥–ª—è –≤—Å–µ—Ö', '—á–µ—Ä–µ–∑ 10 –º–∏–Ω—É—Ç –∑–∞–±–ª–æ–∫–∏—Ä—É–π –≥–æ–ª–æ—Å–æ–≤—ã–µ 321', '—á–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç –∑–∞–ø—Ä–µ—Ç–∏ –∞—É–¥–∏–æ –¥–ª—è –≤—Å–µ—Ö', '—á–µ—Ä–µ–∑ —á–∞—Å –∑–∞–ø—Ä–µ—Ç–∏ –≤—Å–µ–º —Ñ–æ—Ç–æ –∏ –≥–æ–ª–æ—Å–æ–≤—ã–µ, –Ω–æ –æ—Å—Ç–∞–≤—å —Ç–µ–∫—Å—Ç—ã –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ'\n"
            "3. '–°–¥–µ–ª–∞–π —Ç–∞–∫ —á—Ç–æ–±—ã —Å–µ–≥–æ–¥–Ω—è –Ω–µ–ª—å–∑—è –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Ñ–æ—Ç–æ', '—Ä–∞–∑—Ä–µ—à–∏ —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö', '—Ç–æ–ª—å–∫–æ —Ñ–æ—Ç–æ –±–µ–∑ –ª–∏–º–∏—Ç–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è 333', '—Ä–∞–∑—Ä–µ—à–∏ —Ñ–æ—Ç–æ –∏ –∞—É–¥–∏–æ –¥–ª—è –≤—Å–µ—Ö –Ω–∞ 30 –º–∏–Ω—É—Ç, –æ—Å—Ç–∞–ª—å–Ω–æ–µ –æ—Å—Ç–∞–≤–∏—Ç—å'\n"
            "4. '–ö–æ–Ω—Ç–∞–∫—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞: https://t.me/yourlink', '–∏–∑–º–µ–Ω–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –∞–¥–º–∏–Ω–∞', '—Å–≤—è–∑–∞—Ç—å—Å—è —Å –∞–¥–º–∏–Ω–æ–º: @myadmin', '–∞–¥–º–∏–Ω —Ç–µ–ø–µ—Ä—å: https://t.me/newadmin', '–æ–±–Ω–æ–≤–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –∞–¥–º–∏–Ω–∞'\n"
            "5. 'BOT2 —á–µ—Ä–µ–∑ 2 —á–∞—Å–∞ –∑–∞–ø—Ä–µ—Ç–∏ —Ñ–æ—Ç–æ –¥–ª—è –≤—Å–µ—Ö', 'BOT2 —á–µ—Ä–µ–∑ —á–∞—Å —Ä–∞–∑—Ä–µ—à–∏ —Ñ–æ—Ç–æ –¥–ª—è 12345', 'BOT2 —Å–Ω–∏–º–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∞ –≤—Å–µ –¥–ª—è –≤—Å–µ—Ö –Ω–∞ —á–∞—Å', 'BOT2 —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö –Ω–∞ 40 –º–∏–Ω—É—Ç', 'BOT2 —á–µ—Ä–µ–∑ 3 —á–∞—Å–∞ –∑–∞–±–ª–æ–∫–∏—Ä—É–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è 123'\n"
            "6. 'BOT2 –≤ 15:00 —Ä–∞–∑—Ä–µ—à–∏ —Ñ–æ—Ç–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è 555', 'BOT2 —Å 17:00 –ø–æ 18:00 –∑–∞–ø—Ä–µ—Ç–∏ –≥–æ–ª–æ—Å–æ–≤—ã–µ –≤—Å–µ–º'\n"
            "–ü—Ä–∏–º–µ—Ä—ã JSON-–æ—Ç–≤–µ—Ç–æ–≤:\n"
            "‚Äî –°–Ω—è—Ç—å –≤—Å–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –¥–ª—è –≤—Å–µ—Ö –Ω–∞ 1 —á–∞—Å: {\"action\": \"temporary_unlimited\", \"everyone\": true, \"lim_types\": [\"text\",\"photo\",\"voice\"], \"hours\": 1}\n"
            "‚Äî –ß–µ—Ä–µ–∑ 2 —á–∞—Å–∞ –∑–∞–ø—Ä–µ—Ç–∏—Ç—å —Ñ–æ—Ç–æ –≤—Å–µ–º: {\"action\": \"future_action\", \"future\": {\"type\": \"timed_limit\", \"params\": {\"everyone\": true, \"photo\": 0, \"minutes\": 10}}, \"delay_minutes\": 120}\n"
            "‚Äî –ß–µ—Ä–µ–∑ 2 —á–∞—Å–∞ –∑–∞–ø—Ä–µ—Ç–∏—Ç—å —Ñ–æ—Ç–æ –∏ –∞—É–¥–∏–æ –≤—Å–µ–º, –∞ —Ç–µ–∫—Å—Ç—ã —Å–¥–µ–ª–∞—Ç—å –±–µ–∑–ª–∏–º–∏—Ç: {\"action\": \"future_action\", \"future\": {\"type\": \"timed_limit\", \"params\": {\"everyone\": true, \"photo\": 0, \"voice\": 0, \"text\": 999999}}, \"delay_minutes\": 120}\n"
            "‚Äî –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –∞–¥–º–∏–Ω–∞: {\"action\": \"set_admin_link\", \"link\": \"https://t.me/yourlink\"}\n"
            "‚Äî –ß–µ—Ä–µ–∑ 3 —á–∞—Å–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è 123: {\"action\": \"future_action\", \"future\": {\"type\": \"block\", \"params\": {\"user_id\": 123}}, \"delay_minutes\": 180}\n"
            "‚Äî –ß–µ—Ä–µ–∑ 1 —á–∞—Å —Ä–∞–∑—Ä–µ—à–∏—Ç—å —Ñ–æ—Ç–æ –¥–ª—è 456: {\"action\": \"future_action\", \"future\": {\"type\": \"temporary_unlimited\", \"params\": {\"user_id\": 456, \"lim_types\": [\"photo\"], \"minutes\": 60}}, \"delay_minutes\": 0}\n"
            "‚Äî –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è 123: {\"action\": \"block\", \"user_id\": 123, \"hours\": 1}\n"
            "‚Äî –û–≥—Ä–∞–Ω–∏—á–∏—Ç—å —Ñ–æ—Ç–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è 333 –Ω–∞ 5 –º–∏–Ω—É—Ç: {\"action\": \"timed_limit\", \"user_id\": 333, \"photo\": 0, \"minutes\": 5}\n"
            "‚Äî –ß–µ—Ä–µ–∑ 10 –º–∏–Ω—É—Ç —Å–Ω—è—Ç—å –≤—Å–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –¥–ª—è –≤—Å–µ—Ö –Ω–∞ –ø–æ–ª—á–∞—Å–∞: {\"action\": \"future_action\", \"future\": {\"type\": \"temporary_unlimited\", \"params\": {\"everyone\": true, \"lim_types\": [\"text\",\"photo\",\"voice\"], \"minutes\": 30}}, \"delay_minutes\": 10}\n"
            "‚Äî –°–¥–µ–ª–∞—Ç—å —Ç–µ–∫—Å—Ç—ã –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º–∏ –¥–ª—è –≤—Å–µ—Ö: {\"action\": \"temporary_unlimited\", \"everyone\": true, \"lim_types\": [\"text\"], \"hours\": 24}\n"
            "‚Äî –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ –¥–ª—è –ª—é–±—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.\n"
            "–í—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–π –≤–∞–ª–∏–¥–Ω—ã–π JSON. –ï—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è future/delayed action ‚Äî –≤–µ—Ä–Ω–∏ action: future_action –∏ –æ–±—ä–µ–∫—Ç future, delay_minutes.\n"
            "–ö–æ–º–∞–Ω–¥–∞: " + text
        )
        payload = {
            "contents": [
                {"parts": [{"text": prompt}]}
            ]
        }
        result = await gemini_request(payload)
        if "error" in result:
            await message.answer(result["message"])
            return
        reply_text = result.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("text", "")
        try:
            data = json.loads(extract_json_from_gemini(reply_text))
        except Exception:
            await message.answer(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –∫–æ–º–∞–Ω–¥—É.\n–û—Ç–≤–µ—Ç Gemini:\n{reply_text}")
            return

        # --- Future actions ---
        if data.get("action") == "future_action":
            future = data.get("future", {})
            delay = int(data.get("delay_minutes", 0))
            at = (now() + timedelta(minutes=delay)).isoformat()
            future_to_add = {"type": future.get("type"), "params": future.get("params", {}), "at": at}
            future_actions.append(future_to_add)
            backup_data()
            await message.answer("‚è∞ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ —á–µ—Ä–µ–∑ " + str(delay) + " –º–∏–Ω—É—Ç.")
            return

        # --- Temporary unlimited ---
        if data.get("action") == "temporary_unlimited":
            mins = int(data.get("minutes", 0))
            hrs = int(data.get("hours", 0))
            days = int(data.get("days", 0))
            until = now() + timedelta(days=days, hours=hrs, minutes=mins)
            lim_types = data.get("lim_types", ["text", "photo", "voice"])
            if data.get("user_id"):
                uids = [data["user_id"]]
            elif data.get("everyone"):
                uids = list(users_registered)
            else:
                await message.answer("‚ùó –£–∫–∞–∂–∏ user_id –∏–ª–∏ everyone.")
                return
            for u in uids:
                d = get_user(u)
                for t in lim_types:
                    d.setdefault("temporary_unlimited", {})[t] = {
                        "until": until.isoformat(), "old_val": d.get(f"{t}_left", DEFAULT_LIMITS.get(t, 0))
                    }
                    d[f"{t}_left"] = 99999999
            await message.answer("‚úÖ –í—Ä–µ–º–µ–Ω–Ω—ã–µ –ª–∏–º–∏—Ç—ã —Å–Ω—è—Ç—ã.")
            backup_data()
            return

        if data.get("action") == "timed_limit":
            mins = int(data.get("minutes", 0))
            hrs = int(data.get("hours", 0))
            days = int(data.get("days", 0))
            until = now() + timedelta(days=days, hours=hrs, minutes=mins)
            lim_types = []
            for t in ("text", "photo", "voice"):
                if t in data:
                    lim_types.append(t)
            if data.get("user_id"):
                uids = [data["user_id"]]
            elif data.get("everyone"):
                uids = list(users_registered)
            else:
                await message.answer("‚ùó –£–∫–∞–∂–∏ user_id –∏–ª–∏ everyone.")
                return
            for u in uids:
                d = get_user(u)
                for t in lim_types:
                    d[t + "_left"] = data[t]
                    d.setdefault("timed_restrictions", {})[t] = {"until": until.isoformat(), "value": data[t]}
            await message.answer("‚úÖ –í—Ä–µ–º–µ–Ω–Ω–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.")
            backup_data()
            return

        if data.get("action") == "set_admin_link":
            link = data.get("link")
            if link:
                global admin_link
                admin_link = link
                save_admin_link(link)
                await message.answer(f"‚úÖ –°—Å—ã–ª–∫–∞ –Ω–∞ –∞–¥–º–∏–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞: {admin_link}")
            else:
                await message.answer("‚ùó –ù–µ —É–∫–∞–∑–∞–Ω–∞ —Å—Å—ã–ª–∫–∞.")
            return

        # –û—Å—Ç–∞–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ
        action = data.get("action", "")
        uid = data.get("user_id")
        if action == "remove_limits":
            if uid:
                reset_limits(uid)
                log_admin(f"–°–±—Ä–æ—à–µ–Ω—ã –ª–∏–º–∏—Ç—ã {uid}")
                await message.answer(f"‚úÖ –õ–∏–º–∏—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —Å–±—Ä–æ—à–µ–Ω—ã.")
            elif data.get("everyone", False):
                for u in users_registered:
                    reset_limits(u)
                log_admin("–°–±—Ä–æ—à–µ–Ω—ã –ª–∏–º–∏—Ç—ã –¥–ª—è –≤—Å–µ—Ö")
                await message.answer("‚úÖ –õ–∏–º–∏—Ç—ã —Å–±—Ä–æ—à–µ–Ω—ã –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
            else:
                await message.answer("‚ùó –£–∫–∞–∂–∏ user_id –∏–ª–∏ '–≤—Å–µ–º'.")
            backup_data()
            return
        if action == "set_limits":
            lims = {}
            for key in ("text", "voice", "photo", "total"):
                if key in data: lims[key] = data[key]
            if uid:
                set_limits(uid, **lims)
                log_admin(f"–õ–∏–º–∏—Ç—ã –¥–ª—è {uid}: {data}")
                await message.answer(f"‚úÖ –ù–æ–≤—ã–µ –ª–∏–º–∏—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} –ø—Ä–∏–º–µ–Ω–µ–Ω—ã.")
            elif data.get("everyone", False):
                for u in users_registered:
                    set_limits(u, **lims)
                log_admin(f"–õ–∏–º–∏—Ç—ã –¥–ª—è –≤—Å–µ—Ö: {data}")
                await message.answer("‚úÖ –ù–æ–≤—ã–µ –ª–∏–º–∏—Ç—ã –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫–æ –≤—Å–µ–º.")
            else:
                await message.answer("‚ùó –£–∫–∞–∂–∏ user_id –∏–ª–∏ '–≤—Å–µ–º'.")
            backup_data()
            return
        if action == "set_topic":
            until = None
            if "days" in data: until = now() + timedelta(days=int(data["days"]))
            if "hours" in data: until = now() + timedelta(hours=int(data["hours"]))
            if "minutes" in data: until = now() + timedelta(minutes=int(data["minutes"]))
            topic = data.get("topic") or data.get("theme")
            if uid and topic:
                set_topic(uid, topic, until.isoformat() if until else None)
                log_admin(f"–¢–µ–º–∞ {topic} –¥–ª—è {uid} –¥–æ {until}")
                await message.answer(f"‚úÖ –¢–µ–º–∞ {topic} –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.")
            elif data.get("everyone", False) and topic:
                for u in users_registered:
                    set_topic(u, topic, until.isoformat() if until else None)
                log_admin(f"–¢–µ–º–∞ {topic} –¥–ª—è –≤—Å–µ—Ö –¥–æ {until}")
                await message.answer(f"‚úÖ –¢–µ–º–∞ {topic} –¥–ª—è –≤—Å–µ—Ö —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.")
            else:
                await message.answer("‚ùó –£–∫–∞–∂–∏ user_id –∏–ª–∏ '–≤—Å–µ–º', –∏ —Ç–µ–º—É.")
            backup_data()
            return
        if action == "remove_topic":
            if uid:
                remove_topic(uid)
                log_admin(f"–°–Ω—è—Ç–∞ —Ç–µ–º–∞ –¥–ª—è {uid}")
                await message.answer(f"‚úÖ –¢–µ–º–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —Å–Ω—è—Ç–∞.")
            elif data.get("everyone", False):
                for u in users_registered:
                    remove_topic(u)
                log_admin("–°–Ω—è—Ç–∞ —Ç–µ–º–∞ –¥–ª—è –≤—Å–µ—Ö")
                await message.answer("‚úÖ –¢–µ–º—ã —Å–Ω—è—Ç—ã –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
            else:
                await message.answer("‚ùó –£–∫–∞–∂–∏ user_id –∏–ª–∏ '–≤—Å–µ–º'.")
            backup_data()
            return
        if action == "block":
            until = now() + timedelta(hours=3)
            if "hours" in data: until = now() + timedelta(hours=int(data["hours"]))
            if "minutes" in data: until = now() + timedelta(minutes=int(data["minutes"]))
            if "days" in data: until = now() + timedelta(days=int(data["days"]))
            if uid:
                block_user(uid, until.isoformat())
                log_admin(f"–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ {uid}")
                await message.answer(f"‚õî –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥–æ {until.strftime('%d.%m %H:%M')}.")
            elif data.get("everyone", False):
                for u in users_registered:
                    block_user(u, until.isoformat())
                log_admin(f"–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –≤—Å–µ—Ö –¥–æ {until}")
                await message.answer(f"‚õî –í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –¥–æ {until.strftime('%d.%m %H:%M')}.")
            else:
                await message.answer("‚ùó –£–∫–∞–∂–∏ user_id –∏–ª–∏ '–≤—Å–µ–º'.")
            backup_data()
            return
        if action == "unblock":
            if uid:
                unblock_user(uid)
                log_admin(f"–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ {uid}")
                await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
            elif data.get("everyone", False):
                for u in users_registered:
                    unblock_user(u)
                log_admin("–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –≤—Å–µ—Ö")
                await message.answer("‚úÖ –í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.")
            else:
                await message.answer("‚ùó –£–∫–∞–∂–∏ user_id –∏–ª–∏ '–≤—Å–µ–º'.")
            backup_data()
            return
        if action == "clear_memory":
            if uid:
                clear_history(uid)
                log_admin(f"–ü–∞–º—è—Ç—å —Å–±—Ä–æ—à–µ–Ω–∞ {uid}")
                await message.answer(f"‚úÖ –ü–∞–º—è—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —Å–±—Ä–æ—à–µ–Ω–∞.")
            elif data.get("everyone", False):
                for u in users_registered:
                    clear_history(u)
                log_admin("–ü–∞–º—è—Ç—å —Å–±—Ä–æ—à–µ–Ω–∞ —É –≤—Å–µ—Ö")
                await message.answer("‚úÖ –ü–∞–º—è—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å–±—Ä–æ—à–µ–Ω–∞.")
            else:
                await message.answer("‚ùó –£–∫–∞–∂–∏ user_id –∏–ª–∏ '–≤—Å–µ–º'.")
            backup_data()
            return
        if action == "show_limits":
            if uid:
                d = get_user(uid)
                text = (
                    f"üë§ {d['name']} (id: {uid})\n"
                    f"{limits_left_text(uid)}\n"
                )
                if d["topic_mode"]:
                    text += f"\nüîí –¢–µ–º–∞: {d['topic_mode']}"
                if d["blocked"]:
                    text += f"\n‚õî –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω"
                await message.answer(text)
            else:
                await message.answer("‚ùó –£–∫–∞–∂–∏ user_id.")
            return
        if action == "list_users":
            count = int(data.get("count", 10))
            text = "–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:\n\n"
            for u in list(users_registered)[-count:]:
                d = get_user(u)
                text += f"üë§ {d['name']} (id: {u}) | {limits_left_text(u)} | –¢–µ–º–∞: {d['topic_mode'] or '-'} | –ë–ª–æ–∫: {'–¥–∞' if d['blocked'] else '–Ω–µ—Ç'}\n"
            await message.answer(text)
            return
        await message.answer("‚ùì –ù–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–ª –∫–æ–º–∞–Ω–¥—É. –ü—Ä–∏–º–µ—Ä: BOT2 —Å–Ω–∏–º–∏ –≤—Å–µ –ª–∏–º–∏—Ç—ã —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è 12345678")

    return bot, dp

async def main():
    restore_data()
    global bot, dp
    bot, dp = await start_handlers()
    asyncio.create_task(timed_restrictions_checker())
    await start_http_server()
    await bot.send_message(ADMIN_ID, "üü¢ –ë–æ—Ç Soup –∑–∞–ø—É—â–µ–Ω. –ò—Å—Ç–æ—Ä–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å–±—Ä–æ—à–µ–Ω–∞.")
    try:
        await dp.start_polling(bot)
    finally:
        backup_data()

if __name__ == "__main__":
    asyncio.run(main())
